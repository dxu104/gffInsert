# gffInsert Toolkit

The `gffInsert` toolkit is designed for processing and refining transcript annotations in GTF files. This toolkit includes a series of Python scripts that work together to parse, manipulate, and reassemble GTF files for enhanced genomic analysis.

## Overview of Scripts

### Parsing and Preparing Transcripts
1. **find_overlap_transcript**: Identifies overlapping transcripts from a `.combined.gtf` file.
2. **parse_gtf_to_dict_by_cmp_ref**: Converts GTF data to a dictionary format, indexed by `cmp_ref` values.
3. **extract_key_value_pairs**: Extracts key-value pairs from the tracking file generated by `gffcompare`.
4. **check_key_unique** (Optional): Checks if the keys extracted in the previous step are unique.
5. **update_keys_with_tracking_key_value_pair**: Replaces incorrect transcript IDs (keys) with correct gene IDs in the tracking file.

### Processing Reference GTF
1. **parse_gtf_to_dict_by_geneID**: Converts the reference GTF file into a JSON format for easier insertion of new transcripts.

### Organizing Transcripts
1. **separate_transcripts_with_same_cmp_ref_geneID**: Segregates transcripts sharing the same `cmp_ref` and `geneID`, organizing them by their start position.

### Insertion and Sorting
1. **insert_by_start_position**: Implements an insertion sort algorithm to integrate new transcripts into the reference GTF file based on their start positions.

### Finalization
1. **parse_json_gtf**: Converts the JSON data back into the standard GTF format.

### Handling Novel Transcripts
1. **find_novel_transcripts**: Appends novel transcripts, identified by class codes `{'r', 'u', 'i', 'p', 'y'}`, to the end of the final GTF file.

## Workflow Description

The `gffInsert` toolkit follows a structured workflow to enhance transcript annotations:

1. **Prepare Transcripts**: The workflow begins with the identification of overlapping transcripts and their organization into a structured format. This step ensures that new transcripts are ready for insertion into the reference GTF.

2. **Process Reference GTF**: The reference GTF is parsed into a JSON format, facilitating the efficient insertion of new transcripts.

3. **Organize and Insert Transcripts**: New transcripts are organized by their start positions and inserted into the reference GTF. This process is meticulous, ensuring accurate placement and sorting of transcripts.

4. **Convert Back to GTF**: After all insertions are complete, the data in JSON format is converted back into the standard GTF format.

5. **Append Novel Transcripts**: Finally, any novel transcripts identified during the process are appended to the end of the GTF file.

## Technical Notes

- The toolkit offers a streamlined approach to GTF file manipulation, ensuring efficient and accurate transcript annotation.
- The insertion sort algorithm is a key component, allowing precise integration of new transcripts into existing data.
- The toolkit's modular design provides flexibility, allowing users to modify specific parts of the workflow as needed.
- Performance: Running the entire pipeline on a system with 16 GB RAM and a 2.6 GHz 6-Core Intel Core i7 processor takes approximately 40 seconds, demonstrating both efficiency and effectiveness.

## Screenshots and Examples

Based on the novel_class_codes = {'r', 'u', 'i', 'y', 'p'} specified in the XXX.combined/annotated gtf generated by the gffcompare process (using query gtf from stringtie and reference gtf as inputs), I have written a Python script to append these novel transcripts to the reference gtf. Please see the attached append file for details.

Secondly, since inserting potential overlap transcripts (class_codes = {'k', 'm', 'n', 'j', 'e'}) into the appropriate location in the reference gtf involves many search processes, I wrote a function called parse_gtf_to_dict (see attached file) to reduce the O(n) time complexity of future searches to O(1). For example, in the reference gtf, the unique gene ID will be the key in this JSON file, and the gene, transcript, exon, and CDS will be the values.

![image](https://github.com/dxu104/gffInsert/assets/90865804/485cd245-11d0-4045-8324-e6f269fc3c64)

We also have a function to convert JSON back to gtf format (see attached parse_json_gtf).

Next, I wrote a script called find_overlap_transcript to gather all transcripts and exons with class_codes = {'k', 'm', 'n', 'j', 'e'} from the XXX.combined.gtf. Each transcript and its subsequent exons are considered as a whole and are inserted into the reference gtf file. The insertion location is based on the cmp_ref "AMEX60DDU001003602.3" attribute in the 9th field of the gtf file. This cmp_ref serves as an excellent example to demonstrate the insertion and sorting process. 

In the below reference gtf screenshot, multiple transcripts under "AMEX60DDU001003602" are placed in increasing order by their start position (4th field of gtf). Each transcript and its subsequent exons are inserted into the reference gtf based on the same gene ID and start position. Sometimes, in the combined.gtf, two or more potential overlap transcripts and exons may share a similar cmp_ref, like "AMEX60DDU001003602.3", "AMEX60DDU001003602.4", "AMEX60DDU001003602.7". All these transcripts and exons are inserted and sorted simultaneously.

![image](https://github.com/dxu104/gffInsert/assets/90865804/849375f4-5951-409c-af99-a352c3849506)

To implement this, I wrote a function called parse_gtf_to_dict_by_cmp_ref. In the output file named cmp_ref.json, the unique cmp_ref attribute is the key, and the transcripts and exons are the values.  All values in this output JSON file will be correctly inserted into the reference gtf based on the same gene ID (key) and start position.

![image](https://github.com/dxu104/gffInsert/assets/90865804/9ef145e0-cd49-460d-af12-d755655ac9e4)

![image](https://github.com/dxu104/gffInsert/assets/90865804/492fc186-a066-4340-9292-60e2824a00d9)

The screenshot above shows that even under the same cmp_ref, different STRG numbers can result in multiple transcripts. A similar situation occurs in the reference gtf (multiple transcripts under the same gene ID). Thus, I wrote separate_transcripts_with_same_cmp_ref_geneID, where for transcripts and exons, the start_position is the key. For gene or CDS entries, since their start positions are irrelevant to the insertion position, we just set random but unique keys for each.

![image](https://github.com/dxu104/gffInsert/assets/90865804/91f098a1-8e64-42b4-b959-98dedf011e54)

Since the transcripts below share the same start_position as the screenshot below, we combine them into one key-value pair. Then we can insert these two transcripts together into the reference gtf.

![image](https://github.com/dxu104/gffInsert/assets/90865804/68dc7526-fd0b-4866-8c82-f6267b2b8dbe)


Extract Key-Value Pairs:
This script is designed to parse and extract key-value pairs from a GFFCompare tracking file (specified as source_file_path). GFFCompare typically generates tracking files after comparing GTF/GFF files, and these tracking files contain mappings of transcript IDs and GeneID. See below screenshot:


Functionality: The script reads each line of the tracking file, splits it by the '|' symbol, and extracts the key-value pairs. The key is taken from the part after the '|' and up to the first whitespace, while the value is the part before the '|'. These key-value pairs are then saved in a JSON format in an output file.


Update Keys:
This script's purpose is to update the keys in a JSON file (target_file_path, in this case, representing cmp_ref.json) based on the mappings provided in another JSON file (generated by the Extract Key-Value Pairs specified as source_file_path).

Functionality: The script loads both JSON files (source and target). It then iterates through each key-value pair in the target file. For each key, it checks if there's a corresponding new key in the source file. If found, it updates the key in the target data; otherwise, it keeps the original key. The updated key-value pairs are then saved in a new JSON file.


After insert_by_start_position process,
Finally, we start the insertion sort part (see attached insert_by_start_position). The specific insertion sort algorithm involves inserting an ordered array A into another ordered array B. First, a number A[i] is inserted into the ordered array B. If A[i] is found to be smaller than a value B[j] , it is inserted before B[j]. If no such position is found, it implies that the number A[i] is the largest, so A[i] should be appended at the end of the last transcript and exon combination in the already traversed part of B.

Each insertion is based on the current state of the data, which is an important characteristic of the insertion sort algorithm. The elements of array A are the transcript start positions from a specific gene in the XXX.annotation/combined.gtf file, while the elements of array B are the transcript start positions from the same gene in the reference .gtf file.

The last step is to use the parse_json_to_gtf script to generate the final annotation file. 

Additionally, the code offers excellent reusability, allowing modifications to class_codes as needed. Running all the above steps on one 16 GB 2400 MHz DDR4 and 2.6 GHz 6-Core Intel Core i7 takes 40 second, demonstrating efficiency and effectiveness.